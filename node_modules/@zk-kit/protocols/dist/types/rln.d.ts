import { MerkleProof, StrBigInt } from "@zk-kit/types";
import ZkProtocol from "./zk-protocol";
export default class RLN extends ZkProtocol {
    /**
     * Creates witness for rln proof
     * @param identitySecret identity secret
     * @param merkleProof merkle proof that identity exists in RLN tree
     * @param epoch epoch on which signal is broadcasted
     * @param signal signal that is being broadcasted
     * @param rlnIdentifier identifier used by each separate app, needed for more accurate spam filtering
     * @param shouldHash should signal be hashed before broadcast
     * @returns rln witness
     */
    static genWitness(identitySecret: bigint, merkleProof: MerkleProof, epoch: StrBigInt, signal: string, rlnIdentifier: bigint, shouldHash?: boolean): any;
    /**
     * Calculates
     * @param identitySecret identity secret
     * @param epoch epoch on which signal is broadcasted
     * @param rlnIdentifier unique identifier of rln dapp
     * @param x signal hash
     * @returns y & slashing nullfier
     */
    static calculateOutput(identitySecret: bigint, epoch: bigint, rlnIdentifier: bigint, x: bigint): bigint[];
    /**
     *
     * @param a1 y = a1 * x + a0 (a1 = poseidon(identity secret, epoch, rlnIdentifier))
     * @param rlnIdentifier unique identifier of rln dapp
     * @returns rln slashing nullifier
     */
    static genNullifier(a1: bigint, rlnIdentifier: bigint): bigint;
    /**
     * When spam occurs, identity secret can be retrieved
     * @param x1 x1
     * @param x2 x2
     * @param y1 y1
     * @param y2 y2
     * @returns identity secret
     */
    static retrieveSecret(x1: bigint, x2: bigint, y1: bigint, y2: bigint): bigint;
    /**
     *
     * @returns unique identifier of the rln dapp
     */
    static genIdentifier(): bigint;
}
