/**
 * @module @zk-kit/protocols
 * @version 1.5.0
 * @file Client library for generating and verifying Semaphore & RLN ZK proofs.
 * @copyright Andrija Novakovic 2022
 * @license MIT
 * @see [Github]{@link https://github.com/appliedzkp/zk-kit/tree/main/packages/protocols}
*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var circomlibjs = require('circomlibjs');
var bytes = require('@ethersproject/bytes');
var solidity = require('@ethersproject/solidity');
var strings = require('@ethersproject/strings');
var incrementalMerkleTree = require('@zk-kit/incremental-merkle-tree');
var ffjavascript = require('ffjavascript');
var snarkjs = require('snarkjs');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var SNARK_FIELD_SIZE = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var Fq = new ffjavascript.ZqField(SNARK_FIELD_SIZE);
function genSignalHash(signal) {
    var converted = bytes.hexlify(strings.toUtf8Bytes(signal));
    return BigInt(solidity.keccak256(["bytes"], [converted])) >> BigInt(8);
}
function genExternalNullifier(plaintext) {
    var hashed = solidity.keccak256(["string"], [plaintext]);
    var hexStr = "0x".concat(hashed.slice(8));
    var len = 32 * 2;
    var h = hexStr.slice(2, len + 2);
    return "0x".concat(h.padStart(len, "0"));
}
/**
 * Creates a Merkle proof.
 * @param depth The depth of the tree.
 * @param zeroValue The zero value of the tree.
 * @param arity The number of leaves per node.
 * @param leaves The list of the leaves of the tree.
 * @param leaf The leaf for which Merkle proof should be created.
 * @returns The Merkle proof.
 */
function generateMerkleProof(depth, zeroValue, arity, leaves, leaf) {
    var tree = new incrementalMerkleTree.IncrementalMerkleTree(circomlibjs.poseidon, depth, zeroValue, arity);
    var leafIndex = leaves.indexOf(leaf);
    if (leafIndex === -1) {
        throw new Error("The leaf does not exists");
    }
    for (var _i = 0, leaves_1 = leaves; _i < leaves_1.length; _i++) {
        var leaf_1 = leaves_1[_i];
        tree.insert(leaf_1);
    }
    return tree.createProof(leafIndex);
}

var ZkProtocol = /** @class */ (function () {
    function ZkProtocol() {
    }
    /**
     * Generates a SnarkJS full proof with Groth16.
     * @param witness The parameters for creating the proof.
     * @param wasmFilePath The WASM file path.
     * @param finalZkeyPath The ZKey file path.
     * @returns The full SnarkJS proof.
     */
    ZkProtocol.genProof = function (witness, wasmFilePath, finalZkeyPath) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, proof, publicSignals;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, snarkjs.groth16.fullProve(witness, wasmFilePath, finalZkeyPath, null)];
                    case 1:
                        _a = _b.sent(), proof = _a.proof, publicSignals = _a.publicSignals;
                        return [2 /*return*/, { proof: proof, publicSignals: publicSignals }];
                }
            });
        });
    };
    /**
     * Verifies a zero-knowledge SnarkJS proof.
     * @param verificationKey The zero-knowledge verification key.
     * @param fullProof The SnarkJS full proof.
     * @returns True if the proof is valid, false otherwise.
     */
    ZkProtocol.verifyProof = function (verificationKey, fullProof) {
        var proof = fullProof.proof, publicSignals = fullProof.publicSignals;
        return snarkjs.groth16.verify(verificationKey, publicSignals, proof);
    };
    /**
     * Converts a full proof in a proof compatible with the Verifier.sol method inputs.
     * @param fullProof The proof generated with SnarkJS.
     * @returns The Solidity compatible proof.
     */
    ZkProtocol.packToSolidityProof = function (fullProof) {
        var proof = fullProof.proof;
        return [
            proof.pi_a[0],
            proof.pi_a[1],
            proof.pi_b[0][1],
            proof.pi_b[0][0],
            proof.pi_b[1][1],
            proof.pi_b[1][0],
            proof.pi_c[0],
            proof.pi_c[1]
        ];
    };
    return ZkProtocol;
}());

var RLN = /** @class */ (function (_super) {
    __extends(RLN, _super);
    function RLN() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates witness for rln proof
     * @param identitySecret identity secret
     * @param merkleProof merkle proof that identity exists in RLN tree
     * @param epoch epoch on which signal is broadcasted
     * @param signal signal that is being broadcasted
     * @param rlnIdentifier identifier used by each separate app, needed for more accurate spam filtering
     * @param shouldHash should signal be hashed before broadcast
     * @returns rln witness
     */
    RLN.genWitness = function (identitySecret, merkleProof, epoch, signal, rlnIdentifier, shouldHash) {
        if (shouldHash === void 0) { shouldHash = true; }
        return {
            identity_secret: identitySecret,
            path_elements: merkleProof.siblings,
            identity_path_index: merkleProof.pathIndices,
            x: shouldHash ? genSignalHash(signal) : signal,
            epoch: epoch,
            rln_identifier: rlnIdentifier
        };
    };
    /**
     * Calculates
     * @param identitySecret identity secret
     * @param epoch epoch on which signal is broadcasted
     * @param rlnIdentifier unique identifier of rln dapp
     * @param x signal hash
     * @returns y & slashing nullfier
     */
    RLN.calculateOutput = function (identitySecret, epoch, rlnIdentifier, x) {
        var a1 = circomlibjs.poseidon([identitySecret, epoch]);
        var y = Fq.normalize(a1 * x + identitySecret);
        var nullifier = RLN.genNullifier(a1, rlnIdentifier);
        return [y, nullifier];
    };
    /**
     *
     * @param a1 y = a1 * x + a0 (a1 = poseidon(identity secret, epoch, rlnIdentifier))
     * @param rlnIdentifier unique identifier of rln dapp
     * @returns rln slashing nullifier
     */
    RLN.genNullifier = function (a1, rlnIdentifier) {
        return circomlibjs.poseidon([a1, rlnIdentifier]);
    };
    /**
     * When spam occurs, identity secret can be retrieved
     * @param x1 x1
     * @param x2 x2
     * @param y1 y1
     * @param y2 y2
     * @returns identity secret
     */
    RLN.retrieveSecret = function (x1, x2, y1, y2) {
        var slope = Fq.div(Fq.sub(y2, y1), Fq.sub(x2, x1));
        var privateKey = Fq.sub(y1, Fq.mul(slope, x1));
        return Fq.normalize(privateKey);
    };
    /**
     *
     * @returns unique identifier of the rln dapp
     */
    RLN.genIdentifier = function () {
        return Fq.random();
    };
    return RLN;
}(ZkProtocol));

var Semaphore = /** @class */ (function (_super) {
    __extends(Semaphore, _super);
    function Semaphore() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a Semaphore witness for the Semaphore ZK proof.
     * @param identityTrapdoor The identity trapdoor.
     * @param identityNullifier The identity nullifier.
     * @param merkleProof The Merkle proof that identity exists in Semaphore tree.
     * @param externalNullifier The topic on which vote should be broadcasted.
     * @param signal The signal that should be broadcasted.
     * @param shouldHash True if the signal must be hashed before broadcast.
     * @returns The Semaphore witness.
     */
    Semaphore.genWitness = function (identityTrapdoor, identityNullifier, merkleProof, externalNullifier, signal, shouldHash) {
        if (shouldHash === void 0) { shouldHash = true; }
        return {
            identity_nullifier: identityNullifier,
            identity_trapdoor: identityTrapdoor,
            identity_path_index: merkleProof.pathIndices,
            path_elements: merkleProof.siblings,
            external_nullifier: externalNullifier,
            signal_hash: shouldHash ? genSignalHash(signal) : signal
        };
    };
    /**
     * Generates a nullifier by hashing the external and the identity nullifiers.
     * @param externalNullifier The external nullifier.
     * @param identityNullifier The identity nullifier.
     * @returns The nullifier hash.
     */
    Semaphore.genNullifierHash = function (externalNullifier, identityNullifier) {
        return circomlibjs.poseidon([BigInt(externalNullifier), BigInt(identityNullifier)]);
    };
    return Semaphore;
}(ZkProtocol));

exports.RLN = RLN;
exports.Semaphore = Semaphore;
exports.genExternalNullifier = genExternalNullifier;
exports.genSignalHash = genSignalHash;
exports.generateMerkleProof = generateMerkleProof;
