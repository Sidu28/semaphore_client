/**
 * @module @zk-kit/protocols
 * @version 1.3.0
 * @file Client library for generating and verifying Semaphore & RLN ZK proofs.
 * @copyright Andrija Novakovic 2022
 * @license MIT
 * @see [Github]{@link https://github.com/appliedzkp/zk-kit/tree/main/packages/protocols}
*/
import { poseidon } from 'circomlibjs';
import { hexlify } from '@ethersproject/bytes';
import { keccak256 } from '@ethersproject/solidity';
import { toUtf8Bytes } from '@ethersproject/strings';
import { IncrementalMerkleTree } from '@zk-kit/incremental-merkle-tree';
import { ZqField } from 'ffjavascript';
import fs from 'fs';
import { groth16 } from 'snarkjs';

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};
function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var SNARK_FIELD_SIZE = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
var Fq = new ZqField(SNARK_FIELD_SIZE);
function genSignalHash(signal) {
    var converted = hexlify(toUtf8Bytes(signal));
    return BigInt(keccak256(["bytes"], [converted])) >> BigInt(8);
}
function genExternalNullifier(plaintext) {
    var hashed = keccak256(["string"], [plaintext]);
    var hexStr = "0x".concat(hashed.slice(8));
    var len = 32 * 2;
    var h = hexStr.slice(2, len + 2);
    return "0x".concat(h.padStart(len, "0"));
}
/**
 * Returns the content of a file as array buffer. It uses `fetch`
 * on browsers and fs.readFileSync with node.
 * @param filePath The file path.
 * @returns The file content as array buffer.
 */
function getFileBuffer(filePath) {
    return __awaiter(this, void 0, void 0, function () {
        var response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(typeof window !== "undefined")) return [3 /*break*/, 2];
                    return [4 /*yield*/, fetch(filePath)];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, response.arrayBuffer()];
                case 2: return [2 /*return*/, fs.readFileSync(filePath)];
            }
        });
    });
}
/**
 * Creates a Merkle proof.
 * @param depth The depth of the tree.
 * @param zeroValue The zero value of the tree.
 * @param arity The number of leaves per node.
 * @param leaves The list of the leaves of the tree.
 * @param leaf The leaf for which Merkle proof should be created.
 * @returns The Merkle proof.
 */
function generateMerkleProof(depth, zeroValue, arity, leaves, leaf) {
    var tree = new IncrementalMerkleTree(poseidon, depth, zeroValue, arity);
    var leafIndex = leaves.indexOf(leaf);
    if (leafIndex === -1) {
        throw new Error("The leaf does not exists");
    }
    for (var _i = 0, leaves_1 = leaves; _i < leaves_1.length; _i++) {
        var leaf_1 = leaves_1[_i];
        tree.insert(leaf_1);
    }
    return tree.createProof(leafIndex);
}

const builder = async (code, options) => {
  options = options || {};
  const wasmModule = await WebAssembly.compile(code);
  let wc;
  const instance = await WebAssembly.instantiate(wasmModule, {
    runtime: {
      exceptionHandler: function (code) {
        let errStr;
        if (code == 1) {
          errStr = "Signal not found. ";
        } else if (code == 2) {
          errStr = "Too many signals set. ";
        } else if (code == 3) {
          errStr = "Signal already set. ";
        } else if (code == 4) {
          errStr = "Assert Failed. ";
        } else if (code == 5) {
          errStr = "Not enough memory. ";
        } else {
          errStr = "Unknown error\n";
        }
        errStr += getMessage();
        throw new Error(errStr)
      },
      showSharedRWMemory: function () {
        printSharedRWMemory();
      }
    }
  });
  const sanityCheck = options;
  wc = new WitnessCalculator(instance, sanityCheck);
  return wc
  function getMessage() {
    var message = "";
    var c = instance.exports.getMessageChar();
    while (c != 0) {
      message += String.fromCharCode(c);
      c = instance.exports.getMessageChar();
    }
    return message
  }
  function printSharedRWMemory() {
    const shared_rw_memory_size = instance.exports.getFieldNumLen32();
    const arr = new Uint32Array(shared_rw_memory_size);
    for (let j = 0; j < shared_rw_memory_size; j++) {
      arr[shared_rw_memory_size - 1 - j] = instance.exports.readSharedRWMemory(j);
    }
    console.log(fromArray32(arr));
  }
};
class WitnessCalculator {
  constructor(instance, sanityCheck) {
    this.instance = instance;
    this.version = this.instance.exports.getVersion();
    this.n32 = this.instance.exports.getFieldNumLen32();
    this.instance.exports.getRawPrime();
    const arr = new Array(this.n32);
    for (let i = 0; i < this.n32; i++) {
      arr[this.n32 - 1 - i] = this.instance.exports.readSharedRWMemory(i);
    }
    this.prime = fromArray32(arr);
    this.witnessSize = this.instance.exports.getWitnessSize();
    this.sanityCheck = sanityCheck;
  }
  circom_version() {
    return this.instance.exports.getVersion()
  }
  async _doCalculateWitness(input, sanityCheck) {
    this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
    const keys = Object.keys(input);
    keys.forEach((k) => {
      const h = fnvHash(k);
      const hMSB = parseInt(h.slice(0, 8), 16);
      const hLSB = parseInt(h.slice(8, 16), 16);
      const fArr = flatArray(input[k]);
      for (let i = 0; i < fArr.length; i++) {
        const arrFr = toArray32(fArr[i], this.n32);
        for (let j = 0; j < this.n32; j++) {
          this.instance.exports.writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);
        }
        try {
          this.instance.exports.setInputSignal(hMSB, hLSB, i);
        } catch (err) {
          throw new Error(err)
        }
      }
    });
  }
  async calculateWitness(input, sanityCheck) {
    const w = [];
    await this._doCalculateWitness(input, sanityCheck);
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      const arr = new Uint32Array(this.n32);
      for (let j = 0; j < this.n32; j++) {
        arr[this.n32 - 1 - j] = this.instance.exports.readSharedRWMemory(j);
      }
      w.push(fromArray32(arr));
    }
    return w
  }
  async calculateBinWitness(input, sanityCheck) {
    const buff32 = new Uint32Array(this.witnessSize * this.n32);
    const buff = new Uint8Array(buff32.buffer);
    await this._doCalculateWitness(input, sanityCheck);
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      const pos = i * this.n32;
      for (let j = 0; j < this.n32; j++) {
        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
      }
    }
    return buff
  }
  async calculateWTNSBin(input, sanityCheck) {
    const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);
    const buff = new Uint8Array(buff32.buffer);
    await this._doCalculateWitness(input, sanityCheck);
    buff[0] = "w".charCodeAt(0);
    buff[1] = "t".charCodeAt(0);
    buff[2] = "n".charCodeAt(0);
    buff[3] = "s".charCodeAt(0);
    buff32[1] = 2;
    buff32[2] = 2;
    buff32[3] = 1;
    const n8 = this.n32 * 4;
    const idSection1length = 8 + n8;
    const idSection1lengthHex = idSection1length.toString(16);
    buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);
    buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);
    buff32[6] = n8;
    this.instance.exports.getRawPrime();
    var pos = 7;
    for (let j = 0; j < this.n32; j++) {
      buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
    }
    pos += this.n32;
    buff32[pos] = this.witnessSize;
    pos++;
    buff32[pos] = 2;
    pos++;
    const idSection2length = n8 * this.witnessSize;
    const idSection2lengthHex = idSection2length.toString(16);
    buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);
    buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);
    pos += 2;
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      for (let j = 0; j < this.n32; j++) {
        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
      }
      pos += this.n32;
    }
    return buff
  }
}
function toArray32(s, size) {
  const res = [];
  let rem = BigInt(s);
  const radix = BigInt(0x100000000);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  if (size) {
    var i = size - res.length;
    while (i > 0) {
      res.unshift(0);
      i--;
    }
  }
  return res
}
function fromArray32(arr) {
  var res = BigInt(0);
  const radix = BigInt(0x100000000);
  for (let i = 0; i < arr.length; i++) {
    res = res * radix + BigInt(arr[i]);
  }
  return res
}
function flatArray(a) {
  var res = [];
  fillArray(res, a);
  return res
  function fillArray(res, a) {
    if (Array.isArray(a)) {
      for (let i = 0; i < a.length; i++) {
        fillArray(res, a[i]);
      }
    } else {
      res.push(a);
    }
  }
}
function fnvHash(str) {
  const uint64_max = Number(BigInt(2)) ** Number(BigInt(64));
  let hash = BigInt("0xCBF29CE484222325");
  for (var i = 0; i < str.length; i++) {
    hash ^= BigInt(str[i].charCodeAt());
    hash *= BigInt(0x100000001b3);
    hash %= BigInt(uint64_max);
  }
  let shash = hash.toString(16);
  let n = 16 - shash.length;
  shash = "0".repeat(n).concat(shash);
  return shash
}

var ZkProtocol = /** @class */ (function () {
    function ZkProtocol() {
    }
    /**
     * Generates a SnarkJS full proof with Groth16.
     * @param witness The parameters for creating the proof.
     * @param wasmFilePath The WASM file path.
     * @param finalZkeyPath The ZKey file path.
     * @returns The full SnarkJS proof.
     */
    ZkProtocol.genProof = function (witness, wasmFilePath, finalZkeyPath) {
        return __awaiter(this, void 0, void 0, function () {
            var wasmBuff, witnessCalculator, wtnsBuff, zkeyBuff, _a, proof, publicSignals;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, getFileBuffer(wasmFilePath)];
                    case 1:
                        wasmBuff = _b.sent();
                        return [4 /*yield*/, builder(wasmBuff)];
                    case 2:
                        witnessCalculator = _b.sent();
                        return [4 /*yield*/, witnessCalculator.calculateWTNSBin(witness, 0)];
                    case 3:
                        wtnsBuff = _b.sent();
                        return [4 /*yield*/, getFileBuffer(finalZkeyPath)];
                    case 4:
                        zkeyBuff = _b.sent();
                        return [4 /*yield*/, groth16.prove(new Uint8Array(zkeyBuff), wtnsBuff, null)];
                    case 5:
                        _a = _b.sent(), proof = _a.proof, publicSignals = _a.publicSignals;
                        return [2 /*return*/, { proof: proof, publicSignals: publicSignals }];
                }
            });
        });
    };
    /**
     * Verifies a zero-knowledge SnarkJS proof.
     * @param verificationKey The zero-knowledge verification key.
     * @param fullProof The SnarkJS full proof.
     * @returns True if the proof is valid, false otherwise.
     */
    ZkProtocol.verifyProof = function (verificationKey, fullProof) {
        var proof = fullProof.proof, publicSignals = fullProof.publicSignals;
        return groth16.verify(verificationKey, publicSignals, proof);
    };
    /**
     * Converts a full proof in a proof compatible with the Verifier.sol method inputs.
     * @param fullProof The proof generated with SnarkJS.
     * @returns The Solidity compatible proof.
     */
    ZkProtocol.packToSolidityProof = function (fullProof) {
        var proof = fullProof.proof, publicSignals = fullProof.publicSignals;
        return {
            a: [proof.pi_a[0], proof.pi_a[1]],
            b: [
                [proof.pi_b[0][1], proof.pi_b[0][0]],
                [proof.pi_b[1][1], proof.pi_b[1][0]]
            ],
            c: [proof.pi_c[0], proof.pi_c[1]],
            inputs: publicSignals
        };
    };
    return ZkProtocol;
}());

var RLN = /** @class */ (function (_super) {
    __extends(RLN, _super);
    function RLN() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates witness for rln proof
     * @param identitySecret identity secret
     * @param merkleProof merkle proof that identity exists in RLN tree
     * @param epoch epoch on which signal is broadcasted
     * @param signal signal that is being broadcasted
     * @param rlnIdentifier identifier used by each separate app, needed for more accurate spam filtering
     * @param shouldHash should signal be hashed before broadcast
     * @returns rln witness
     */
    RLN.genWitness = function (identitySecret, merkleProof, epoch, signal, rlnIdentifier, shouldHash) {
        if (shouldHash === void 0) { shouldHash = true; }
        return {
            identity_secret: identitySecret,
            path_elements: merkleProof.siblings,
            identity_path_index: merkleProof.pathIndices,
            x: shouldHash ? genSignalHash(signal) : signal,
            epoch: epoch,
            rln_identifier: rlnIdentifier
        };
    };
    /**
     * Calculates
     * @param identitySecret identity secret
     * @param epoch epoch on which signal is broadcasted
     * @param rlnIdentifier unique identifier of rln dapp
     * @param x signal hash
     * @returns y & slashing nullfier
     */
    RLN.calculateOutput = function (identitySecret, epoch, rlnIdentifier, x) {
        var a1 = poseidon([identitySecret, epoch]);
        var y = Fq.normalize(a1 * x + identitySecret);
        var nullifier = RLN.genNullifier(a1, rlnIdentifier);
        return [y, nullifier];
    };
    /**
     *
     * @param a1 y = a1 * x + a0 (a1 = poseidon(identity secret, epoch, rlnIdentifier))
     * @param rlnIdentifier unique identifier of rln dapp
     * @returns rln slashing nullifier
     */
    RLN.genNullifier = function (a1, rlnIdentifier) {
        return poseidon([a1, rlnIdentifier]);
    };
    /**
     * When spam occurs, identity secret can be retrieved
     * @param x1 x1
     * @param x2 x2
     * @param y1 y1
     * @param y2 y2
     * @returns identity secret
     */
    RLN.retrieveSecret = function (x1, x2, y1, y2) {
        var slope = Fq.div(Fq.sub(y2, y1), Fq.sub(x2, x1));
        var privateKey = Fq.sub(y1, Fq.mul(slope, x1));
        return Fq.normalize(privateKey);
    };
    /**
     *
     * @returns unique identifier of the rln dapp
     */
    RLN.genIdentifier = function () {
        return Fq.random();
    };
    return RLN;
}(ZkProtocol));

var Semaphore = /** @class */ (function (_super) {
    __extends(Semaphore, _super);
    function Semaphore() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a Semaphore witness for the Semaphore ZK proof.
     * @param identityTrapdoor The identity trapdoor.
     * @param identityNullifier The identity nullifier.
     * @param merkleProof The Merkle proof that identity exists in Semaphore tree.
     * @param externalNullifier The topic on which vote should be broadcasted.
     * @param signal The signal that should be broadcasted.
     * @param shouldHash True if the signal must be hashed before broadcast.
     * @returns The Semaphore witness.
     */
    Semaphore.genWitness = function (identityTrapdoor, identityNullifier, merkleProof, externalNullifier, signal, shouldHash) {
        if (shouldHash === void 0) { shouldHash = true; }
        return {
            identity_nullifier: identityNullifier,
            identity_trapdoor: identityTrapdoor,
            identity_path_index: merkleProof.pathIndices,
            path_elements: merkleProof.siblings,
            external_nullifier: externalNullifier,
            signal_hash: shouldHash ? genSignalHash(signal) : signal
        };
    };
    /**
     * Generates a nullifier by hashing the external and the identity nullifiers.
     * @param externalNullifier The external nullifier.
     * @param identityNullifier The identity nullifier.
     * @returns The nullifier hash.
     */
    Semaphore.genNullifierHash = function (externalNullifier, identityNullifier) {
        return poseidon([BigInt(externalNullifier), BigInt(identityNullifier)]);
    };
    return Semaphore;
}(ZkProtocol));

export { RLN, Semaphore, genExternalNullifier, genSignalHash, generateMerkleProof };
