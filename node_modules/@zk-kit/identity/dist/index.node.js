/**
 * @module @zk-kit/identity
 * @version 1.4.1
 * @file Library for managing identities for Semaphore and RLN protocols.
 * @copyright Andrija Novakovic 2022
 * @license MIT
 * @see [Github]{@link https://github.com/appliedzkp/zk-kit/tree/main/packages/identity}
*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var bignumber = require('@ethersproject/bignumber');
var circomlibjs = require('circomlibjs');
var random = require('@ethersproject/random');
var jsSha256 = require('js-sha256');

/**
 * Returns an hexadecimal sha256 hash of the message passed as parameter.
 * @param message The string to hash.
 * @returns The hexadecimal hash of the message.
 */
function sha256(message) {
    var hash = jsSha256.sha256.create();
    hash.update(message);
    return hash.hex();
}
/**
 * Generates a random big number.
 * @param numberOfBytes The number of bytes of the number.
 * @returns The generated random number.
 */
function genRandomNumber(numberOfBytes) {
    if (numberOfBytes === void 0) { numberOfBytes = 31; }
    return bignumber.BigNumber.from(random.randomBytes(numberOfBytes)).toBigInt();
}

// The strategy used to generate the ZK identity.
exports.Strategy = void 0;
(function (Strategy) {
    Strategy[Strategy["RANDOM"] = 0] = "RANDOM";
    Strategy[Strategy["MESSAGE"] = 1] = "MESSAGE";
    Strategy[Strategy["SERIALIZED"] = 2] = "SERIALIZED"; // Identity parameters are passed from outside.
})(exports.Strategy || (exports.Strategy = {}));
/**
 * ZkIdentity is a class which can be used by protocols supported by the
 * @zk-key/protocols package and it simplifies the management of
 * identity-related witness parameters.
 */
var ZkIdentity = /** @class */ (function () {
    /**
     * Initializes the class attributes based on the strategy passed as parameter.
     * @param strategy The strategy for identity generation.
     * @param metadata Additional data needed to create identity for given strategy.
     */
    function ZkIdentity(strategy, metadata) {
        if (strategy === void 0) { strategy = exports.Strategy.RANDOM; }
        this._secret = [];
        switch (strategy) {
            case exports.Strategy.RANDOM: {
                this._identityTrapdoor = genRandomNumber();
                this._identityNullifier = genRandomNumber();
                this._secret = [this._identityNullifier, this._identityTrapdoor];
                break;
            }
            case exports.Strategy.MESSAGE: {
                if (!metadata) {
                    throw new Error("The message is not defined");
                }
                if (typeof metadata !== "string") {
                    throw new Error("The message is not a string");
                }
                var messageHash = sha256(metadata);
                this._identityTrapdoor = bignumber.BigNumber.from("0x".concat(sha256("".concat(messageHash, "identity_trapdoor")))).toBigInt();
                this._identityNullifier = bignumber.BigNumber.from("0x".concat(sha256("".concat(messageHash, "identity_nullifier")))).toBigInt();
                this._secret = [this._identityNullifier, this._identityTrapdoor];
                break;
            }
            case exports.Strategy.SERIALIZED: {
                if (!metadata) {
                    throw new Error("The serialized identity is not defined");
                }
                if (typeof metadata === "string") {
                    try {
                        metadata = JSON.parse(metadata);
                    }
                    catch (error) {
                        throw new Error("The serialized identity cannot be parsed");
                    }
                }
                if (!("identityNullifier" in metadata) || !("identityTrapdoor" in metadata) || !("secret" in metadata)) {
                    throw new Error("The serialized identity does not contain the right parameter");
                }
                var identityNullifier = metadata.identityNullifier, identityTrapdoor = metadata.identityTrapdoor, secret = metadata.secret;
                this._identityNullifier = bignumber.BigNumber.from("0x".concat(identityNullifier)).toBigInt();
                this._identityTrapdoor = bignumber.BigNumber.from("0x".concat(identityTrapdoor)).toBigInt();
                this._secret = secret.map(function (item) { return bignumber.BigNumber.from("0x".concat(item)).toBigInt(); });
                break;
            }
            default:
                throw new Error("The provided strategy is not supported");
        }
    }
    /**
     * Returns the identity trapdoor.
     * @returns The identity trapdoor.
     */
    ZkIdentity.prototype.getTrapdoor = function () {
        return this._identityTrapdoor;
    };
    /**
     * Returns the identity nullifier.
     * @returns The identity nullifier.
     */
    ZkIdentity.prototype.getNullifier = function () {
        return this._identityNullifier;
    };
    /**
     * Returns the secret.
     * @returns The secret.
     */
    ZkIdentity.prototype.getSecret = function () {
        return this._secret;
    };
    /**
     * Returns the Poseidon hash of the secret.
     * @returns The hash of the secret.
     */
    ZkIdentity.prototype.getSecretHash = function () {
        return circomlibjs.poseidon(this._secret);
    };
    /**
     * Generates the identity commitment from the secret.
     * @returns identity commitment
     */
    ZkIdentity.prototype.genIdentityCommitment = function () {
        return circomlibjs.poseidon([this.getSecretHash()]);
    };
    /**
     * Serializes the class attributes and returns a stringified object.
     * @returns The stringified serialized identity.
     */
    ZkIdentity.prototype.serializeIdentity = function () {
        var data = {
            identityNullifier: this._identityNullifier.toString(16),
            identityTrapdoor: this._identityTrapdoor.toString(16),
            secret: this._secret.map(function (item) { return item.toString(16); })
        };
        return JSON.stringify(data);
    };
    return ZkIdentity;
}());

exports.ZkIdentity = ZkIdentity;
