/**
 * @module @zk-kit/identity
 * @version 1.4.1
 * @file Library for managing identities for Semaphore and RLN protocols.
 * @copyright Andrija Novakovic 2022
 * @license MIT
 * @see [Github]{@link https://github.com/appliedzkp/zk-kit/tree/main/packages/identity}
*/
import { BigNumber } from '@ethersproject/bignumber';
import { poseidon } from 'circomlibjs';
import { randomBytes } from '@ethersproject/random';
import { sha256 as sha256$1 } from 'js-sha256';

/**
 * Returns an hexadecimal sha256 hash of the message passed as parameter.
 * @param message The string to hash.
 * @returns The hexadecimal hash of the message.
 */
function sha256(message) {
    var hash = sha256$1.create();
    hash.update(message);
    return hash.hex();
}
/**
 * Generates a random big number.
 * @param numberOfBytes The number of bytes of the number.
 * @returns The generated random number.
 */
function genRandomNumber(numberOfBytes) {
    if (numberOfBytes === void 0) { numberOfBytes = 31; }
    return BigNumber.from(randomBytes(numberOfBytes)).toBigInt();
}

// The strategy used to generate the ZK identity.
var Strategy;
(function (Strategy) {
    Strategy[Strategy["RANDOM"] = 0] = "RANDOM";
    Strategy[Strategy["MESSAGE"] = 1] = "MESSAGE";
    Strategy[Strategy["SERIALIZED"] = 2] = "SERIALIZED"; // Identity parameters are passed from outside.
})(Strategy || (Strategy = {}));
/**
 * ZkIdentity is a class which can be used by protocols supported by the
 * @zk-key/protocols package and it simplifies the management of
 * identity-related witness parameters.
 */
var ZkIdentity = /** @class */ (function () {
    /**
     * Initializes the class attributes based on the strategy passed as parameter.
     * @param strategy The strategy for identity generation.
     * @param metadata Additional data needed to create identity for given strategy.
     */
    function ZkIdentity(strategy, metadata) {
        if (strategy === void 0) { strategy = Strategy.RANDOM; }
        this._secret = [];
        switch (strategy) {
            case Strategy.RANDOM: {
                this._identityTrapdoor = genRandomNumber();
                this._identityNullifier = genRandomNumber();
                this._secret = [this._identityNullifier, this._identityTrapdoor];
                break;
            }
            case Strategy.MESSAGE: {
                if (!metadata) {
                    throw new Error("The message is not defined");
                }
                if (typeof metadata !== "string") {
                    throw new Error("The message is not a string");
                }
                var messageHash = sha256(metadata);
                this._identityTrapdoor = BigNumber.from("0x".concat(sha256("".concat(messageHash, "identity_trapdoor")))).toBigInt();
                this._identityNullifier = BigNumber.from("0x".concat(sha256("".concat(messageHash, "identity_nullifier")))).toBigInt();
                this._secret = [this._identityNullifier, this._identityTrapdoor];
                break;
            }
            case Strategy.SERIALIZED: {
                if (!metadata) {
                    throw new Error("The serialized identity is not defined");
                }
                if (typeof metadata === "string") {
                    try {
                        metadata = JSON.parse(metadata);
                    }
                    catch (error) {
                        throw new Error("The serialized identity cannot be parsed");
                    }
                }
                if (!("identityNullifier" in metadata) || !("identityTrapdoor" in metadata) || !("secret" in metadata)) {
                    throw new Error("The serialized identity does not contain the right parameter");
                }
                var identityNullifier = metadata.identityNullifier, identityTrapdoor = metadata.identityTrapdoor, secret = metadata.secret;
                this._identityNullifier = BigNumber.from("0x".concat(identityNullifier)).toBigInt();
                this._identityTrapdoor = BigNumber.from("0x".concat(identityTrapdoor)).toBigInt();
                this._secret = secret.map(function (item) { return BigNumber.from("0x".concat(item)).toBigInt(); });
                break;
            }
            default:
                throw new Error("The provided strategy is not supported");
        }
    }
    /**
     * Returns the identity trapdoor.
     * @returns The identity trapdoor.
     */
    ZkIdentity.prototype.getTrapdoor = function () {
        return this._identityTrapdoor;
    };
    /**
     * Returns the identity nullifier.
     * @returns The identity nullifier.
     */
    ZkIdentity.prototype.getNullifier = function () {
        return this._identityNullifier;
    };
    /**
     * Returns the secret.
     * @returns The secret.
     */
    ZkIdentity.prototype.getSecret = function () {
        return this._secret;
    };
    /**
     * Returns the Poseidon hash of the secret.
     * @returns The hash of the secret.
     */
    ZkIdentity.prototype.getSecretHash = function () {
        return poseidon(this._secret);
    };
    /**
     * Generates the identity commitment from the secret.
     * @returns identity commitment
     */
    ZkIdentity.prototype.genIdentityCommitment = function () {
        return poseidon([this.getSecretHash()]);
    };
    /**
     * Serializes the class attributes and returns a stringified object.
     * @returns The stringified serialized identity.
     */
    ZkIdentity.prototype.serializeIdentity = function () {
        var data = {
            identityNullifier: this._identityNullifier.toString(16),
            identityTrapdoor: this._identityTrapdoor.toString(16),
            secret: this._secret.map(function (item) { return item.toString(16); })
        };
        return JSON.stringify(data);
    };
    return ZkIdentity;
}());

export { Strategy, ZkIdentity };
